{"version":3,"file":"js/32.js","mappings":"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","sources":["webpack://chronicle/./src/components/Preloader.vue","webpack://chronicle/./src/components/Preloader.vue?4c3a","webpack://chronicle/./src/components/Preloader.vue?0692","webpack://chronicle/./src/components/Preloader.vue?f88c","webpack://chronicle/./src/views/ModelViewer3D.vue","webpack://chronicle/./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","webpack://chronicle/./node_modules/three/examples/jsm/loaders/GLTFLoader.js","webpack://chronicle/./node_modules/three/examples/jsm/loaders/RGBELoader.js","webpack://chronicle/./node_modules/three/examples/jsm/loaders/DRACOLoader.js","webpack://chronicle/./src/views/ModelViewer3D.vue?f351","webpack://chronicle/./src/views/ModelViewer3D.vue?6783","webpack://chronicle/./src/views/ModelViewer3D.vue?b3f3"],"sourcesContent":["var render = function render(){var _vm=this,_c=_vm._self._c,_setup=_vm._self._setupProxy;return _c('div',{staticClass:\"preloader\",class:{ full: _vm.full, fill: _vm.fill }},[_c('span',{staticClass:\"loader\",attrs:{\"data-loader-type\":_vm.loader_type}})])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\r\nimport Vue from 'vue';\r\n\r\nexport enum ELoaderType {\r\n    Default = 'default',\r\n    DefaultInner = 'default-inner',\r\n    Alternate01 = 'alternate-01',\r\n    Alternate02 = 'alternate-02',\r\n    Coffee = 'coffee',\r\n    Chiptune = 'chiptune'\r\n\r\n}\r\n\r\nexport default Vue.extend({\r\n    name: 'Preloader',\r\n    data() {\r\n        return {}\r\n    },\r\n    props: {\r\n        full: {\r\n            type: Boolean,\r\n            default: false\r\n        },\r\n        fill: {\r\n            type: Boolean,\r\n            default: false\r\n        },\r\n        loader_type: {\r\n            type: String,\r\n            default: ELoaderType.Alternate01\r\n        }\r\n    },\r\n    mounted() { },\r\n    methods: {}\r\n});\r\n","import mod from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??clonedRuleSet-41.use[2]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Preloader.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??clonedRuleSet-41.use[2]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Preloader.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./Preloader.vue?vue&type=template&id=676665e7&scoped=true&\"\nimport script from \"./Preloader.vue?vue&type=script&lang=ts&\"\nexport * from \"./Preloader.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./Preloader.vue?vue&type=style&index=0&id=676665e7&prod&scoped=true&lang=less&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"676665e7\",\n  null\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c,_setup=_vm._self._setupProxy;return _c('div',{staticClass:\"model-viewer-3d\",class:{ mobile: _vm.is_mobile },on:{\"keydown\":_vm.handle_keydown,\"dragenter\":function($event){$event.preventDefault();return _vm.handle_dragenter.apply(null, arguments)},\"dragover\":function($event){$event.preventDefault();return _vm.handle_dragover.apply(null, arguments)},\"drop\":function($event){$event.preventDefault();return _vm.handle_drop.apply(null, arguments)}}},[_c('ThreeRenderer',{ref:\"three_renderer\",attrs:{\"download_image_name\":_vm.download_image_name,\"show_controls\":!_vm.dragging,\"show_helpers\":_vm.show_helpers,\"orbit_controls\":_vm.orbit_controls,\"rendering_mode\":_vm.rendering_mode,\"camera_fov\":_vm.camera_fov}},[_c('div',{staticClass:\"separator\"}),_c('p',{staticClass:\"button open-file\",on:{\"click\":_vm.open_file}},[_vm._v(\"open file\")]),_c('div',{staticClass:\"separator\"}),_c('p',{staticClass:\"button\",class:{ active: _vm.show_flashlight },on:{\"click\":function($event){_vm.show_flashlight = !_vm.show_flashlight}}},[_vm._v(\"flashlight \")]),_c('p',{staticClass:\"button\",class:{ active: _vm.show_background, disabled: _vm.rendering_mode !== _vm.EThreeSceneRenderinMode.Default },on:{\"click\":function($event){_vm.show_background = !_vm.show_background}}},[_vm._v(\"background \")]),_c('p',{staticClass:\"button rendering-mode\",attrs:{\"data-rendering-mode\":_vm.rendering_mode_label},domProps:{\"innerHTML\":_vm._s(_vm.rendering_mode_label)},on:{\"click\":_vm.toggle_rendering_mode}}),_c('div',{staticClass:\"separator\"}),(_vm.model || _vm.hdri)?_c('p',{staticClass:\"button clear scene\",on:{\"click\":_vm.clear_scene}},[_vm._v(\"clear all\")]):_vm._e()]),(_vm.info)?_c('Showdown',{staticClass:\"model-info\",attrs:{\"src\":_vm.info}}):_vm._e(),(_vm.is_loading)?_c('div',{staticClass:\"loader-container\"},[_c('Preloader')],1):_vm._e(),(!_vm.is_mobile)?_c('div',{staticClass:\"drop-target\",class:{ dragging: _vm.dragging }},[(_vm.dragging)?_c('p',[_vm._v(\"Drag and drop an image here\")]):_vm._e()]):_vm._e(),_c('input',{ref:\"fileInput\",staticStyle:{\"display\":\"none\"},attrs:{\"type\":\"file\",\"accept\":\"*\"},on:{\"change\":_vm.handle_file_upload}}),(!_vm.dragging)?_c('div',{staticClass:\"info\"}):_vm._e()],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().' ); // @deprecated, r151\n\treturn mergeGeometries( geometries, useGroups );\n\n}\n\nfunction mergeBufferAttributes( attributes ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().' ); // @deprecated, r151\n\treturn mergeAttributes( attributes );\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeBufferGeometries,\n\tmergeAttributes,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","import {\n\tAnimationClip,\n\tBone,\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tColorManagement,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFrontSide,\n\tGroup,\n\tImageBitmapLoader,\n\tInstancedMesh,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tInterpolant,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLine,\n\tLineBasicMaterial,\n\tLineLoop,\n\tLineSegments,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLinearSRGBColorSpace,\n\tLoader,\n\tLoaderUtils,\n\tMaterial,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPoints,\n\tPointsMaterial,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSphere,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tSRGBColorSpace\n} from 'three';\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js';\n\nclass GLTFLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureAVIFExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( parser );\n\n\t\t} );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\tresourcePath = this.path;\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\tsetDDSLoader() {\n\n\t\tthrow new Error(\n\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t);\n\n\t}\n\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet json;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tjson = JSON.parse( data );\n\n\t\t} else if ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tjson = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );\n\n\t\t\t} else {\n\n\t\t\t\tjson = JSON.parse( textDecoder.decode( data ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tjson = data;\n\n\t\t}\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n\tparseAsync( data, path ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( data, path, resolve, reject );\n\n\t\t} );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n\tKHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tKHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_TEXTURE_AVIF: 'EXT_texture_avif',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n\tEXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tassignExtrasToUserData( lightNode, lightDef );\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tgetDependency( type, index ) {\n\n\t\tif ( type !== 'light' ) return;\n\n\t\treturn this._loadLight( index );\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;\n\n\t\tif ( emissiveStrength !== undefined ) {\n\n\t\t\tmaterialParams.emissiveIntensity = emissiveStrength;\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.iridescenceFactor !== undefined ) {\n\n\t\t\tmaterialParams.iridescence = extension.iridescenceFactor;\n\n\t\t}\n\n\t\tif ( extension.iridescenceTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );\n\n\t\t}\n\n\t\tif ( extension.iridescenceIor !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceIOR = extension.iridescenceIor;\n\n\t\t}\n\n\t\tif ( materialParams.iridescenceThicknessRange === undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange = [ 100, 400 ];\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMinimum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMaximum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\n\t\tmaterialParams.sheenRoughness = 0;\n\t\tmaterialParams.sheen = 1;\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.sheenColorFactor !== undefined ) {\n\n\t\t\tconst colorFactor = extension.sheenColorFactor;\n\t\t\tmaterialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor [ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.sheenColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n\t\tif ( extension.thicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\n\t\tmaterialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n\t\tif ( extension.specularTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\n\n\t\t}\n\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\n\t\tmaterialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\tif ( extension.specularColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.anisotropyStrength !== undefined ) {\n\n\t\t\tmaterialParams.anisotropy = extension.anisotropyStrength;\n\n\t\t}\n\n\t\tif ( extension.anisotropyRotation !== undefined ) {\n\n\t\t\tmaterialParams.anisotropyRotation = extension.anisotropyRotation;\n\n\t\t}\n\n\t\tif ( extension.anisotropyTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image.\n\t\t\t\timage.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn buffer.then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst source = new Uint8Array( res, byteOffset, byteLength );\n\n\t\t\t\tif ( decoder.decodeGltfBufferAsync ) {\n\n\t\t\t\t\treturn decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {\n\n\t\t\t\t\t\treturn res.buffer;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n\t\t\t\t\treturn decoder.ready.then( function () {\n\n\t\t\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n\t\tthis.parser = parser;\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||\n\t\t\tnodeDef.mesh === undefined ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst meshDef = json.meshes[ nodeDef.mesh ];\n\n\t\t// No Points or Lines + Instancing support yet\n\n\t\tfor ( const primitive of meshDef.primitives ) {\n\n\t\t\tif ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n\t\t\t\t primitive.mode !== undefined ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensionDef = nodeDef.extensions[ this.name ];\n\t\tconst attributesDef = extensionDef.attributes;\n\n\t\t// @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n\t\tconst pending = [];\n\t\tconst attributes = {};\n\n\t\tfor ( const key in attributesDef ) {\n\n\t\t\tpending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {\n\n\t\t\t\tattributes[ key ] = accessor;\n\t\t\t\treturn attributes[ key ];\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tif ( pending.length < 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tpending.push( this.parser.createNodeMesh( nodeIndex ) );\n\n\t\treturn Promise.all( pending ).then( results => {\n\n\t\t\tconst nodeObject = results.pop();\n\t\t\tconst meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];\n\t\t\tconst count = results[ 0 ].count; // All attribute counts should be same\n\t\t\tconst instancedMeshes = [];\n\n\t\t\tfor ( const mesh of meshes ) {\n\n\t\t\t\t// Temporal variables\n\t\t\t\tconst m = new Matrix4();\n\t\t\t\tconst p = new Vector3();\n\t\t\t\tconst q = new Quaternion();\n\t\t\t\tconst s = new Vector3( 1, 1, 1 );\n\n\t\t\t\tconst instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tif ( attributes.TRANSLATION ) {\n\n\t\t\t\t\t\tp.fromBufferAttribute( attributes.TRANSLATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.ROTATION ) {\n\n\t\t\t\t\t\tq.fromBufferAttribute( attributes.ROTATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.SCALE ) {\n\n\t\t\t\t\t\ts.fromBufferAttribute( attributes.SCALE, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinstancedMesh.setMatrixAt( i, m.compose( p, q, s ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Add instance attributes to the geometry, excluding TRS.\n\t\t\t\tfor ( const attributeName in attributes ) {\n\n\t\t\t\t\tif ( attributeName !== 'TRANSLATION' &&\n\t\t\t\t\t\t attributeName !== 'ROTATION' &&\n\t\t\t\t\t\t attributeName !== 'SCALE' ) {\n\n\t\t\t\t\t\tmesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Just in case\n\t\t\t\tObject3D.prototype.copy.call( instancedMesh, mesh );\n\n\t\t\t\tthis.parser.assignFinalMaterial( instancedMesh );\n\n\t\t\t\tinstancedMeshes.push( instancedMesh );\n\n\t\t\t}\n\n\t\t\tif ( nodeObject.isGroup ) {\n\n\t\t\t\tnodeObject.clear();\n\n\t\t\t\tnodeObject.add( ... instancedMeshes );\n\n\t\t\t\treturn nodeObject;\n\n\t\t\t}\n\n\t\t\treturn instancedMeshes[ 0 ];\n\n\t\t} );\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tthis.header = {\n\t\t\tmagic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = textDecoder.decode( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType.name;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )\n\t\t\t&& transform.offset === undefined\n\t\t\t&& transform.rotation === undefined\n\t\t\t&& transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\ttexture.channel = transform.texCoord;\n\n\t\t}\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer;\n\t\tconst values = this.sampleValues;\n\t\tconst stride = this.valueSize;\n\n\t\tconst stride2 = stride * 2;\n\t\tconst stride3 = stride * 3;\n\n\t\tconst td = t1 - t0;\n\n\t\tconst p = ( t - t0 ) / td;\n\t\tconst pp = p * p;\n\t\tconst ppp = pp * p;\n\n\t\tconst offset1 = i1 * stride3;\n\t\tconst offset0 = offset1 - stride3;\n\n\t\tconst s2 = - 2 * ppp + 3 * pp;\n\t\tconst s3 = ppp - pp;\n\t\tconst s0 = 1 - s2;\n\t\tconst s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nconst _q = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\n\n\t\t_q.fromArray( result ).normalize().toArray( result );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: NearestFilter,\n\t9729: LinearFilter,\n\t9984: NearestMipmapNearestFilter,\n\t9985: LinearMipmapNearestFilter,\n\t9986: NearestMipmapLinearFilter,\n\t9987: LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: ClampToEdgeWrapping,\n\t33648: MirroredRepeatWrapping,\n\t10497: RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv1',\n\tTEXCOORD_2: 'uv2',\n\tTEXCOORD_3: 'uv3',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\tlet hasMorphColor = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\tconst pendingColorAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphColor ) {\n\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\n\t\t\t\t: geometry.attributes.color;\n\n\t\t\tpendingColorAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors ),\n\t\tPromise.all( pendingColorAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\t\tconst morphColors = accessors[ 2 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tlet geometryKey;\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\tif ( primitiveDef.targets !== undefined ) {\n\n\t\tfor ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {\n\n\t\t\tgeometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );\n\n\t\t}\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\nfunction getImageURIMimeType( uri ) {\n\n\tif ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg';\n\tif ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp';\n\n\treturn 'image/png';\n\n}\n\nconst _identityMatrix = new Matrix4();\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Node cache\n\t\tthis.nodeCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.sourceCache = {};\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\n\t\tlet isSafari = false;\n\t\tlet isFirefox = false;\n\t\tlet firefoxVersion = - 1;\n\n\t\tif ( typeof navigator !== 'undefined' ) {\n\n\t\t\tisSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;\n\t\t\tisFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;\n\t\t\tfirefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1;\n\n\t\t}\n\n\t\tif ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {\n\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\t\tthis.nodeCache = {};\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\n\t\t// original object from being lost.\n\t\tconst updateMappings = ( original, clone ) => {\n\n\t\t\tconst mappings = this.associations.get( original );\n\t\t\tif ( mappings != null ) {\n\n\t\t\t\tthis.associations.set( clone, mappings );\n\n\t\t\t}\n\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\n\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tupdateMappings( object, ref );\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadNode && ext.loadNode( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadAnimation && ext.loadAnimation( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext != this && ext.getDependency && ext.getDependency( type, index );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( ! dependency ) {\n\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\t\t\tconst normalized = accessorDef.normalized === true;\n\n\t\t\tconst array = new TypedArray( accessorDef.count * itemSize );\n\t\t\treturn Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture|null>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceIndex = textureDef.source;\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( sourceDef.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\n\n\t\t\ttexture.flipY = false;\n\n\t\t\ttexture.name = textureDef.name || sourceDef.name || '';\n\n\t\t\tif ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {\n\n\t\t\t\ttexture.name = sourceDef.uri;\n\n\t\t\t}\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\n\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\tloadImageSource( sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\n\n\t\t\treturn this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );\n\n\t\t}\n\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = sourceDef.uri || '';\n\t\tlet isObjectURL = false;\n\n\t\tif ( sourceDef.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( sourceDef.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function ( error ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\tthrow error;\n\n\t\t} );\n\n\t\tthis.sourceCache[ sourceIndex ] = promise;\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise<Texture>}\n\t */\n\tassignTexture( materialParams, mapName, mapDef, colorSpace ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\tif ( ! texture ) return null;\n\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {\n\n\t\t\t\ttexture = texture.clone();\n\t\t\t\ttexture.channel = mapDef.texCoord;\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = colorSpace;\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new PointsMaterial();\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new LineBasicMaterial();\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\tlineMaterial.map = material.map;\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\n\t\t\t\tif ( useDerivativeTangents ) {\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\n\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tconst emissiveFactor = materialDef.emissiveFactor;\n\t\t\tmaterialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tconst material = new materialType( materialParams );\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tif ( sanitizedName in this.nodeNamesUsed ) {\n\n\t\t\treturn sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );\n\n\t\t} else {\n\n\t\t\tthis.nodeNamesUsed[ sanitizedName ] = 0;\n\n\t\t\treturn sanitizedName;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t// normalize skin weights to fix malformed assets (see #15319)\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tparser.associations.set( meshes[ i ], {\n\t\t\t\t\tmeshes: meshIndex,\n\t\t\t\t\tprimitives: i\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\n\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );\n\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Skeleton>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {\n\n\t\t\tpending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );\n\n\t\t}\n\n\t\tif ( skinDef.inverseBindMatrices !== undefined ) {\n\n\t\t\tpending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );\n\n\t\t} else {\n\n\t\t\tpending.push( null );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst inverseBindMatrices = results.pop();\n\t\t\tconst jointNodes = results;\n\n\t\t\t// Note that bones (joint nodes) may or may not be in the\n\t\t\t// scene graph at this time.\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( let i = 0, il = jointNodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst jointNode = jointNodes[ i ];\n\n\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\tconst mat = new Matrix4();\n\n\t\t\t\t\tif ( inverseBindMatrices !== null ) {\n\n\t\t\t\t\t\tmat.fromArray( inverseBindMatrices.array, i * 16 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tif ( target.node === undefined ) continue;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tif ( node.updateMatrix ) {\n\n\t\t\t\t\tnode.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tconst createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\n\n\t\t\t\tif ( createdTracks ) {\n\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\n\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( animationName, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tconst nodePending = parser._loadNodeShallow( nodeIndex );\n\n\t\tconst childPending = [];\n\t\tconst childrenDef = nodeDef.children || [];\n\n\t\tfor ( let i = 0, il = childrenDef.length; i < il; i ++ ) {\n\n\t\t\tchildPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );\n\n\t\t}\n\n\t\tconst skeletonPending = nodeDef.skin === undefined\n\t\t\t? Promise.resolve( null )\n\t\t\t: parser.getDependency( 'skin', nodeDef.skin );\n\n\t\treturn Promise.all( [\n\t\t\tnodePending,\n\t\t\tPromise.all( childPending ),\n\t\t\tskeletonPending\n\t\t] ).then( function ( results ) {\n\n\t\t\tconst node = results[ 0 ];\n\t\t\tconst children = results[ 1 ];\n\t\t\tconst skeleton = results[ 2 ];\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t// This full traverse should be fine because\n\t\t\t\t// child glTF nodes have not been added to this node yet.\n\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\tif ( ! mesh.isSkinnedMesh ) return;\n\n\t\t\t\t\tmesh.bind( skeleton, _identityMatrix );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tnode.add( children[ i ] );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t// ._loadNodeShallow() parses a single node.\n\t// skin and child nodes are created and added in .loadNode() (no '_' prefix).\n\t_loadNodeShallow( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\t// This method is called from .loadNode() and .loadSkin().\n\t\t// Cache a node to avoid duplication.\n\n\t\tif ( this.nodeCache[ nodeIndex ] !== undefined ) {\n\n\t\t\treturn this.nodeCache[ nodeIndex ];\n\n\t\t}\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\tconst pending = [];\n\n\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t} );\n\n\t\tif ( meshPromise ) {\n\n\t\t\tpending.push( meshPromise );\n\n\t\t}\n\n\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t} ).forEach( function ( promise ) {\n\n\t\t\tpending.push( promise );\n\n\t\t} );\n\n\t\tthis.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! parser.associations.has( node ) ) {\n\n\t\t\t\tparser.associations.set( node, {} );\n\n\t\t\t}\n\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t\treturn this.nodeCache[ nodeIndex ];\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( parser.getDependency( 'node', nodeIds[ i ] ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( nodes ) {\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tscene.add( nodes[ i ] );\n\n\t\t\t}\n\n\t\t\t// Removes dangling associations, associations that reference a node that\n\t\t\t// didn't make it into the scene.\n\t\t\tconst reduceAssociations = ( node ) => {\n\n\t\t\t\tconst reducedAssociations = new Map();\n\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\n\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\n\n\t\t\t\t\t\treducedAssociations.set( key, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnode.traverse( ( node ) => {\n\n\t\t\t\t\tconst mappings = parser.associations.get( node );\n\n\t\t\t\t\tif ( mappings != null ) {\n\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reducedAssociations;\n\n\t\t\t};\n\n\t\t\tparser.associations = reduceAssociations( scene );\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n\t_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {\n\n\t\tconst tracks = [];\n\n\t\tconst targetName = node.name ? node.name : node.uuid;\n\t\tconst targetNames = [];\n\n\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\ttargetNames.push( targetName );\n\n\t\t}\n\n\t\tlet TypedKeyframeTrack;\n\n\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.position:\n\t\t\tcase PATH_PROPERTIES.scale:\n\n\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tswitch ( outputAccessor.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\n\t\tconst outputArray = this._getArrayFromAccessor( outputAccessor );\n\n\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\tinputAccessor.array,\n\t\t\t\toutputArray,\n\t\t\t\tinterpolation\n\t\t\t);\n\n\t\t\t// Override interpolation with custom factory method.\n\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\tthis._createCubicSplineTrackInterpolant( track );\n\n\t\t\t}\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\t_getArrayFromAccessor( accessor ) {\n\n\t\tlet outputArray = accessor.array;\n\n\t\tif ( accessor.normalized ) {\n\n\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t}\n\n\t\t\toutputArray = scaled;\n\n\t\t}\n\n\t\treturn outputArray;\n\n\t}\n\n\t_createCubicSplineTrackInterpolant( track ) {\n\n\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n\n\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t};\n\n\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new Vector3();\n\t\tconst vector = new Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tif ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {\n\n\t\tconsole.warn( `THREE.GLTFLoader: Converting vertex colors from \"srgb-linear\" to \"${ColorManagement.workingColorSpace}\" not supported.` );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\nexport { GLTFLoader };\n","import {\n\tDataTextureLoader,\n\tDataUtils,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearSRGBColorSpace\n} from 'three';\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.type = HalfFloatType;\n\n\t}\n\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\tparse( buffer ) {\n\n\t\tconst\n\t\t\t/* default error routine.  change this to change error handling */\n\t\t\trgbe_read_error = 1,\n\t\t\trgbe_write_error = 2,\n\t\t\trgbe_format_error = 3,\n\t\t\trgbe_memory_error = 4,\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\n\n\t\t\t\tswitch ( rgbe_error_code ) {\n\n\t\t\t\t\tcase rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) );\n\t\t\t\t\tcase rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) );\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\n\t\t\t//RGBE_DATA_RED = 0,\n\t\t\t//RGBE_DATA_GREEN = 1,\n\t\t\t//RGBE_DATA_BLUE = 2,\n\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\t\t\t//RGBE_DATA_SIZE = 4,\n\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\n\t\t\tRGBE_VALID_FORMAT = 2,\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\n\n\t\t\tNEWLINE = '\\n',\n\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\n\n\t\t\t\tconst chunkSize = 128;\n\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\n\t\t\t\tlet p = buffer.pos,\n\t\t\t\t\ti = - 1, len = 0, s = '',\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\n\n\t\t\t\t\ts += chunk; len += chunk.length;\n\t\t\t\t\tp += chunkSize;\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( - 1 < i ) {\n\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\n\t\t\t\t\treturn s + chunk.slice( 0, i );\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\n\n\n\t\t\t\t// regexes to parse header info fields\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\t\t\t\t\t// RGBE format header struct\n\t\t\t\t\theader = {\n\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\t\t\t\tstring: '', /* the actual header string */\n\n\t\t\t\t\t\tcomments: '', /* comments found in header */\n\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t\t\t\t};\n\n\t\t\t\tlet line, match;\n\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_read_error, 'no header found' );\n\n\t\t\t\t}\n\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'bad initial token' );\n\n\t\t\t\t}\n\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\t\t\theader.programtype = match[ 1 ];\n\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tline = fgets( buffer );\n\t\t\t\t\tif ( false === line ) break;\n\t\t\t\t\theader.string += line + '\\n';\n\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\n\n\t\t\t\t\t\theader.comments += line + '\\n';\n\t\t\t\t\t\tcontinue; // comment line\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\n\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\n\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\n\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing format specifier' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'missing image size specifier' );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t},\n\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\n\n\t\t\t\tconst scanline_width = w;\n\n\t\t\t\tif (\n\t\t\t\t\t// run length encoding is not allowed so read flat\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\n\t\t\t\t\t// this file is not run length encoded\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\n\t\t\t\t) {\n\n\t\t\t\t\t// return the flat buffer\n\t\t\t\t\treturn new Uint8Array( buffer );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\n\n\t\t\t\t\trgbe_error( rgbe_format_error, 'wrong scanline width' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\n\n\t\t\t\tif ( ! data_rgba.length ) {\n\n\t\t\t\t\trgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\n\n\t\t\t\t}\n\n\t\t\t\tlet offset = 0, pos = 0;\n\n\t\t\t\tconst ptr_end = 4 * scanline_width;\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\n\t\t\t\tlet num_scanlines = h;\n\n\t\t\t\t// read in each successive scanline\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_read_error );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\n\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\n\n\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t\t\t// first red, then green, then blue, then exponent\n\t\t\t\t\tlet ptr = 0, count;\n\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\n\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\n\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\n\n\t\t\t\t\t\t\trgbe_error( rgbe_format_error, 'bad scanline data' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isEncodedRun ) {\n\n\t\t\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//ptr += count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// a literal-run\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\n\t\t\t\t\t\t\tptr += count; pos += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// now convert data from buffer into rgba\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\t\t\tlet off = 0;\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toff += scanline_width; //1;\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnum_scanlines --;\n\n\t\t\t\t}\n\n\t\t\t\treturn data_rgba;\n\n\t\t\t};\n\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\n\t\t\tdestArray[ destOffset + 3 ] = 1;\n\n\t\t};\n\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\n\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\n\n\t\t\t// clamping to 65504, the maximum representable value in float16\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\n\n\t\t};\n\n\t\tconst byteArray = new Uint8Array( buffer );\n\t\tbyteArray.pos = 0;\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\n\n\t\tconst w = rgbe_header_info.width,\n\t\t\th = rgbe_header_info.height,\n\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\n\n\n\t\tlet data, type;\n\t\tlet numElements;\n\n\t\tswitch ( this.type ) {\n\n\t\t\tcase FloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = floatArray;\n\t\t\t\ttype = FloatType;\n\t\t\t\tbreak;\n\n\t\t\tcase HalfFloatType:\n\n\t\t\t\tnumElements = image_rgba_data.length / 4;\n\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\n\n\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\n\n\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\n\n\t\t\t\t}\n\n\t\t\t\tdata = halfArray;\n\t\t\t\ttype = HalfFloatType;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthrow new Error( 'THREE.RGBELoader: unsupported type: ', this.type );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn {\n\t\t\twidth: w, height: h,\n\t\t\tdata: data,\n\t\t\theader: rgbe_header_info.string,\n\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\texposure: rgbe_header_info.exposure,\n\t\t\ttype: type\n\t\t};\n\n\t}\n\n\tsetDataType( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.colorSpace = LinearSRGBColorSpace;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\n\n\t}\n\n}\n\nexport { RGBELoader };\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tLoader,\n\tLinearSRGBColorSpace,\n\tSRGBColorSpace\n} from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t}\n\n\tsetDecoderPath( path ) {\n\n\t\tthis.decoderPath = path;\n\n\t\treturn this;\n\n\t}\n\n\tsetDecoderConfig( config ) {\n\n\t\tthis.decoderConfig = config;\n\n\t\treturn this;\n\n\t}\n\n\tsetWorkerLimit( workerLimit ) {\n\n\t\tthis.workerLimit = workerLimit;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\tthis.parse( buffer, onLoad, onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( buffer, onLoad, onError ) {\n\n\t\tthis.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace ).catch( onError );\n\n\t}\n\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace ) {\n\n\t\tconst taskConfig = {\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\tuseUniqueIDs: !! attributeIDs,\n\t\t\tvertexColorSpace: vertexColorSpace,\n\t\t};\n\n\t\treturn this.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t}\n\n\tdecodeGeometry( buffer, taskConfig ) {\n\n\t\tconst taskKey = JSON.stringify( taskConfig );\n\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t// again from this thread.\n\t\tif ( _taskCache.has( buffer ) ) {\n\n\t\t\tconst cachedTask = _taskCache.get( buffer );\n\n\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\treturn cachedTask.promise;\n\n\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\tthrow new Error(\n\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet worker;\n\t\tconst taskID = this.workerNextTaskID ++;\n\t\tconst taskCost = buffer.byteLength;\n\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t// when the task completes.\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t.then( ( _worker ) => {\n\n\t\t\t\tworker = _worker;\n\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t// Remove task from the task list.\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\t\tgeometryPending\n\t\t\t.catch( () => true )\n\t\t\t.then( () => {\n\n\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t// Cache the task result.\n\t\t_taskCache.set( buffer, {\n\n\t\t\tkey: taskKey,\n\t\t\tpromise: geometryPending\n\n\t\t} );\n\n\t\treturn geometryPending;\n\n\t}\n\n\t_createGeometry( geometryData ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( geometryData.index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\tconst result = geometryData.attributes[ i ];\n\t\t\tconst name = result.name;\n\t\t\tconst array = result.array;\n\t\t\tconst itemSize = result.itemSize;\n\n\t\t\tconst attribute = new BufferAttribute( array, itemSize );\n\n\t\t\tif ( name === 'color' ) {\n\n\t\t\t\tthis._assignVertexColorSpace( attribute, result.vertexColorSpace );\n\n\t\t\t\tattribute.normalized = ( array instanceof Float32Array ) === false;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( name, attribute );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\t_assignVertexColorSpace( attribute, inputColorSpace ) {\n\n\t\t// While .drc files do not specify colorspace, the only 'official' tooling\n\t\t// is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc\n\t\t// file is passed into .load() or .parse(). GLTFLoader uses internal APIs\n\t\t// to decode geometry, and vertex colors are already Linear-sRGB in there.\n\n\t\tif ( inputColorSpace !== SRGBColorSpace ) return;\n\n\t\tconst _color = new Color();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\t_color.fromBufferAttribute( attribute, i ).convertSRGBToLinear();\n\t\t\tattribute.setXYZ( i, _color.r, _color.g, _color.b );\n\n\t\t}\n\n\t}\n\n\t_loadLibrary( url, responseType ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.decoderPath );\n\t\tloader.setResponseType( responseType );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t} );\n\n\t}\n\n\tpreload() {\n\n\t\tthis._initDecoder();\n\n\t\treturn this;\n\n\t}\n\n\t_initDecoder() {\n\n\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\tconst librariesPending = [];\n\n\t\tif ( useJS ) {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t} else {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t}\n\n\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t.then( ( libraries ) => {\n\n\t\t\t\tconst jsContent = libraries[ 0 ];\n\n\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst fn = DRACOWorker.toString();\n\n\t\t\t\tconst body = [\n\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\tjsContent,\n\t\t\t\t\t'',\n\t\t\t\t\t'/* worker */',\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t} );\n\n\t\treturn this.decoderPending;\n\n\t}\n\n\t_getWorker( taskID, taskCost ) {\n\n\t\treturn this._initDecoder().then( () => {\n\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\n\n\t\t\t\tworker._callbacks = {};\n\t\t\t\tworker._taskCosts = {};\n\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\tconst message = e.data;\n\n\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t} else {\n\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\tworker._taskLoad += taskCost;\n\t\t\treturn worker;\n\n\t\t} );\n\n\t}\n\n\t_releaseTask( worker, taskID ) {\n\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\tdelete worker._callbacks[ taskID ];\n\t\tdelete worker._taskCosts[ taskID ];\n\n\t}\n\n\tdebug() {\n\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t}\n\n\t\tthis.workerPool.length = 0;\n\n\t\tif ( this.workerSourceURL !== '' ) {\n\n\t\t\tURL.revokeObjectURL( this.workerSourceURL );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n\n\tlet decoderConfig;\n\tlet decoderPending;\n\n\tonmessage = function ( e ) {\n\n\t\tconst message = e.data;\n\n\t\tswitch ( message.type ) {\n\n\t\t\tcase 'init':\n\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\tcase 'decode':\n\t\t\t\tconst buffer = message.buffer;\n\t\t\t\tconst taskConfig = message.taskConfig;\n\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\tconst draco = module.draco;\n\t\t\t\t\tconst decoder = new draco.Decoder();\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );\n\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t} finally {\n\n\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction decodeGeometry( draco, decoder, array, taskConfig ) {\n\n\t\tconst attributeIDs = taskConfig.attributeIDs;\n\t\tconst attributeTypes = taskConfig.attributeTypes;\n\n\t\tlet dracoGeometry;\n\t\tlet decodingStatus;\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType( array );\n\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\tdecodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );\n\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\tdecodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t}\n\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t}\n\n\t\tconst geometry = { index: null, attributes: [] };\n\n\t\t// Gather all vertex attributes.\n\t\tfor ( const attributeName in attributeIDs ) {\n\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\tlet attribute;\n\t\t\tlet attributeID;\n\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t} else {\n\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t}\n\n\t\t\tconst attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );\n\n\t\t\tif ( attributeName === 'color' ) {\n\n\t\t\t\tattributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\n\n\t\t\t}\n\n\t\t\tgeometry.attributes.push( attributeResult );\n\n\t\t}\n\n\t\t// Add index.\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n\t\t}\n\n\t\tdraco.destroy( dracoGeometry );\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\n\n\t\tconst numFaces = dracoGeometry.num_faces();\n\t\tconst numIndices = numFaces * 3;\n\t\tconst byteLength = numIndices * 4;\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn { array: index, itemSize: 1 };\n\n\t}\n\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\tconst numComponents = attribute.num_components();\n\t\tconst numPoints = dracoGeometry.num_points();\n\t\tconst numValues = numPoints * numComponents;\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n\t\tconst dataType = getDracoDataType( draco, attributeType );\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn {\n\t\t\tname: attributeName,\n\t\t\tarray: array,\n\t\t\titemSize: numComponents\n\t\t};\n\n\t}\n\n\tfunction getDracoDataType( draco, attributeType ) {\n\n\t\tswitch ( attributeType ) {\n\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\n\t\t\tcase Int8Array: return draco.DT_INT8;\n\t\t\tcase Int16Array: return draco.DT_INT16;\n\t\t\tcase Int32Array: return draco.DT_INT32;\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\n\n\t\t}\n\n\t}\n\n}\n\nexport { DRACOLoader };\n","\r\n\r\nimport * as THREE from 'three';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\r\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\r\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\r\nimport mixins from 'vue-typed-mixins'\r\nimport ThreeRenderer, { EThreeSceneRenderinMode } from '@/components/ThreeRenderer.vue';\r\nimport Preloader from '@/components/Preloader.vue';\r\nimport BaseComponent from '@/components/BaseComponent.vue';\r\nimport { debounce, isArray } from 'lodash';\r\nimport { get_file_extension } from '@/tools';\r\n\r\n\r\nconst draco_loader = new DRACOLoader();\r\ndraco_loader.setDecoderPath('assets/bin/draco/gltf/');\r\nconst gltf_loader = new GLTFLoader(); // Create a GLTFLoader instance\r\ngltf_loader.setDRACOLoader(draco_loader);\r\nconst rgbe_loader = new RGBELoader(); // Create a RGBELoader instance\r\n\r\nexport default mixins(BaseComponent).extend({\r\n    name: 'ModelViewer3D',\r\n    components: {\r\n        ThreeRenderer,\r\n        Preloader\r\n    },\r\n    data() {\r\n        return {\r\n            dragging: false,\r\n            download_image_name: 'rendered_frame',\r\n            mouse_mode: -1,\r\n            prev_pointer_position: { x: 0, y: 0 },\r\n            mode: 1,\r\n            grid: true,\r\n            tiling: 2,\r\n            environment: null,\r\n            model: null,\r\n            hdri: null,\r\n            is_loading: false,\r\n            flashlight: null,\r\n            EThreeSceneRenderinMode: EThreeSceneRenderinMode\r\n        };\r\n    },\r\n    computed: {\r\n        is_mobile() {\r\n            return this.$store.state.is_mobile_device;\r\n        },\r\n        rendering_mode_label() {\r\n            return EThreeSceneRenderinMode[this.rendering_mode].toLocaleLowerCase()\r\n        }\r\n    },\r\n    props: {\r\n        model_src: {\r\n            type: String,\r\n            default: null,\r\n        },\r\n        hdri_src: {\r\n            type: String,\r\n            default: 'assets/hdri/studio.hdr',\r\n        },\r\n        show_background: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        show_helpers: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        orbit_controls: {\r\n            type: Boolean,\r\n            default: true,\r\n        },\r\n        orbit_controls_autorotate: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        orbit_controls_autorotate_speed: {\r\n            type: Number,\r\n            default: 0.5,\r\n        },\r\n        orbit_controls_pan: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        orbit_controls_zoom: {\r\n            type: Boolean,\r\n            default: true,\r\n        },\r\n        orbit_controls_rotate: {\r\n            type: Boolean,\r\n            default: true,\r\n        },\r\n        reset_camera_on_space: {\r\n            type: Boolean,\r\n            default: true,\r\n        },\r\n        default_camera_distance: {\r\n            type: Number,\r\n            default: 1,\r\n        },\r\n        camera_fov: {\r\n            type: Number,\r\n            default: 60,\r\n        },\r\n        show_flashlight: {\r\n            type: Boolean,\r\n            default: true,\r\n        },\r\n        model_orientation: {\r\n            type: Number,\r\n            default: 0,\r\n        },\r\n        info: {\r\n            type: String,\r\n            default: null\r\n        },\r\n        rendering_mode: {\r\n            type: Number,\r\n            default: EThreeSceneRenderinMode.Default,\r\n        },\r\n\r\n    },\r\n    mounted() {\r\n        debounce(this.set_loading.bind(this), 500);\r\n        this.init()\r\n        document.addEventListener('keydown', this.handle_keydown);\r\n\r\n        console.log(this.info, this.model_src)\r\n\r\n        if (this.orbit_controls) {\r\n\r\n            this.$refs.three_renderer.controls.maxDistance = 3\r\n            this.$refs.three_renderer.controls.maxPolarAngle = Math.PI\r\n\r\n            this.$refs.three_renderer.controls.enableDamping = true;\r\n            this.$refs.three_renderer.controls.dampingFactor = 0.05;\r\n            this.$refs.three_renderer.controls.rotateSpeed = 0.75;\r\n            this.$refs.three_renderer.controls.zoomSpeed = 0.75;\r\n            this.$refs.three_renderer.controls.panSpeed = 0.75;\r\n\r\n\r\n            this.$refs.three_renderer.controls.enableZoom = this.orbit_controls_zoom;\r\n            this.$refs.three_renderer.controls.enableRotate = this.orbit_controls_rotate;\r\n            this.$refs.three_renderer.controls.enablePan = this.orbit_controls_pan;\r\n\r\n            if (this.orbit_controls_autorotate) {\r\n                this.$refs.three_renderer.controls.autoRotate = true;\r\n                this.$refs.three_renderer.controls.autoRotateSpeed = this.orbit_controls_autorotate_speed;\r\n                this.$refs.three_renderer.controls.enableZoom = false;\r\n                this.$refs.three_renderer.controls.enableRotate = false;\r\n                this.$refs.three_renderer.controls.enablePan = false;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        // this.$refs.three_renderer.scene.background = new THREE.Color(0x000000);\r\n    },\r\n    beforeDestroy() {\r\n        this.clear_scene()\r\n        document.removeEventListener('keydown', this.handle_keydown);\r\n    },\r\n    watch: {\r\n        show_flashlight() {\r\n            this.flashlight.visible = this.show_flashlight\r\n        },\r\n        show_background(new_val, old_val) {\r\n            console.log(new_val, this.hdri)\r\n            this.$refs.three_renderer.scene.background = new_val ? this.hdri : null;\r\n        },\r\n    },\r\n    methods: {\r\n        async init() {\r\n            if (this.hdri_src) {\r\n                this.set_hdri(await this.load_hdri_file(this.hdri_src))\r\n            }\r\n            if (this.model_src) {\r\n                this.set_model(await this.load_gltf_file(this.model_src))\r\n            }\r\n\r\n            let flashlight = this.flashlight = new THREE.PointLight(0xffffff, 0.5)\r\n            flashlight.visible = this.show_flashlight\r\n            this.$refs.three_renderer.camera.add(flashlight);\r\n        },\r\n        set_loading(is_loading) {\r\n            this.is_loading = is_loading\r\n\r\n        },\r\n        open_file() {\r\n            // Trigger the file input click event\r\n            this.$refs.fileInput.click();\r\n        },\r\n        // New method to handle dropped files\r\n        async handle_drop(event) {\r\n            event.preventDefault();\r\n            this.dragging = false;\r\n            const files = event.dataTransfer.files;\r\n            if (files.length > 0) {\r\n                const file = files[0]; // Assuming you only handle one file\r\n                console.log(`File dropped: ${file.name}`)\r\n                this.info = null\r\n                await this.load_file(file)\r\n            }\r\n        },\r\n        fit_camera_to_model() {\r\n            let bounding_box = new THREE.Box3().setFromObject(this.model);\r\n            let center = bounding_box.getCenter(new THREE.Vector3());\r\n            let size = bounding_box.getSize(new THREE.Vector3());\r\n            let max_dim = Math.max(size.x, size.y, size.z);\r\n\r\n            let scale = 1 / max_dim;\r\n            this.model.position.set(\r\n                -center.x * scale,\r\n                -center.y * scale,\r\n                -center.z * scale\r\n            );\r\n\r\n            this.model.rotation.y = Math.PI / 3 + (this.model_orientation * Math.PI / 180);\r\n            this.model.scale.setScalar(scale);\r\n            this.reset_camera()\r\n        },\r\n        // New method to handle dragenter event\r\n        handle_dragenter(event) {\r\n            this.dragging = true;\r\n            event.preventDefault();\r\n        },\r\n        // New method to handle dragover event\r\n        handle_dragover(event) {\r\n            event.preventDefault();\r\n        },\r\n        handle_file_upload(event) {\r\n            console.log(`File uploaded: ${event.target.files[0].name}`)\r\n            const file = event.target.files[0];\r\n            if (!file) return;\r\n\r\n            this.info = null\r\n            this.load_file(file)\r\n        },\r\n        async load_file(file): Promise<any> {\r\n            let extension = get_file_extension(file.name);\r\n            console.log(`File extension: ${extension}`)\r\n            switch (extension) {\r\n                case 'hdr':\r\n                    let hdri = await this.load_hdri_file(URL.createObjectURL(file))\r\n                    this.set_hdri(hdri)\r\n                    break;\r\n                case 'gltf':\r\n                case 'glb':\r\n                    let model = await this.load_gltf_file(URL.createObjectURL(file))\r\n                    this.set_model(model)\r\n                    break;\r\n                default:\r\n                    console.error(`Unsupported file extension: ${extension}`)\r\n            }\r\n        },\r\n        dispose_model() {\r\n            this.model.traverse((child) => {\r\n                if (child instanceof THREE.Mesh) {\r\n                    child.geometry.dispose();\r\n                    child.material.dispose();\r\n                }\r\n            });\r\n            this.$refs.three_renderer.scene.remove(this.model);\r\n            this.model = null\r\n        },\r\n        patch_model(model) {\r\n            model.traverse((object) => {\r\n                if (object.isMesh) {\r\n                    let materials = isArray(object.material) ? object.material : [object.material]\r\n                    materials.forEach((element) => {\r\n                        if (element.transparent) {\r\n                            element.depthWrite = true\r\n                            element.alphaHash = true\r\n                        }\r\n                    });\r\n                }\r\n            })\r\n        },\r\n        set_hdri(hdri) {\r\n            this.hdri = hdri\r\n            this.$refs.three_renderer.scene.environment = hdri;\r\n            if (this.show_background) {\r\n                this.$refs.three_renderer.scene.background = hdri;\r\n            }\r\n\r\n        },\r\n        set_model(model) {\r\n            this.$refs.three_renderer.scene.remove(this.model);\r\n            this.model = model\r\n            this.$refs.three_renderer.scene.add(model);\r\n            this.patch_model(this.model)\r\n            this.fit_camera_to_model()\r\n\r\n        },\r\n        load_hdri_file(file_src) {\r\n            console.log(`loading hdri: ${file_src}`)\r\n\r\n            return new Promise((resolve, reject) => {\r\n                this.set_loading(true);\r\n                // Load a HDR texture\r\n                rgbe_loader.load(\r\n                    file_src,\r\n                    (texture) => {\r\n                        // The HDR texture has loaded\r\n                        // You can now use the texture for renderings\r\n                        texture.mapping = THREE.EquirectangularReflectionMapping;\r\n                        resolve(texture)\r\n                        this.set_loading(false);\r\n                    },\r\n                    undefined,\r\n                    (error) => {\r\n                        // An error occurred\r\n                        console.error('Error loading HDR texture:', error);\r\n                        reject(error)\r\n                        this.set_loading(false);\r\n                    }\r\n                );\r\n            })\r\n        },\r\n        load_gltf_file(file_src) {\r\n            console.log(`File uploaded: ${file_src}`)\r\n            return new Promise((resolve, reject) => {\r\n                this.set_loading(true)\r\n                // Load the GLTF model\r\n                gltf_loader.load(\r\n                    file_src,\r\n                    (gltf) => {\r\n                        // The GLTF model has loaded successfully\r\n                        // You can add the loaded model to your Three.js scene here\r\n                        const model = gltf.scene;\r\n                        // Add the model to your scene\r\n                        resolve(model)\r\n                        this.set_loading(false)\r\n                    },\r\n                    undefined,\r\n                    (error) => {\r\n                        // Handle loading errors here\r\n                        console.error('Error loading GLTF file:', error);\r\n                        reject(error)\r\n                        this.set_loading(false)\r\n                    }\r\n                );\r\n            })\r\n        },\r\n        clear_scene() {\r\n            this.dispose_model(this.model)\r\n            this.model = null\r\n            this.$refs.three_renderer.scene.environment = null;\r\n            this.$refs.three_renderer.scene.background = null;\r\n        },\r\n        reset_camera() {\r\n            this.$refs.three_renderer.set_camera_position(new THREE.Vector3(this.default_camera_distance, this.default_camera_distance / 2, this.default_camera_distance));\r\n            this.$refs.three_renderer.set_camera_target(new THREE.Vector3(0, 0, 0));\r\n        },\r\n        handle_keydown(event) {\r\n            /** reset camera on space keydown */\r\n            if (this.reset_camera_on_space && event.keyCode === 32) {\r\n                this.reset_camera()\r\n            }\r\n        },\r\n        toggle_rendering_mode() {\r\n            let modes_count = Object.keys(EThreeSceneRenderinMode).length / 2;\r\n            this.rendering_mode = (this.rendering_mode + 1) % modes_count\r\n\r\n        }\r\n    }\r\n});\r\n","import mod from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??clonedRuleSet-41.use[2]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ModelViewer3D.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??clonedRuleSet-41.use[2]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ModelViewer3D.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./ModelViewer3D.vue?vue&type=template&id=c50bceb2&\"\nimport script from \"./ModelViewer3D.vue?vue&type=script&lang=ts&\"\nexport * from \"./ModelViewer3D.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./ModelViewer3D.vue?vue&type=style&index=0&id=c50bceb2&prod&lang=less&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"names":["ELoaderType","render","_vm","this","_c","_self","_setupProxy","staticClass","class","full","fill","attrs","loader_type","staticRenderFns","Vue","extend","name","data","props","type","Boolean","default","String","Alternate01","mounted","methods","component","mobile","is_mobile","on","handle_keydown","$event","preventDefault","handle_dragenter","apply","arguments","handle_dragover","handle_drop","ref","download_image_name","dragging","show_helpers","orbit_controls","rendering_mode","camera_fov","open_file","_v","active","show_flashlight","show_background","disabled","EThreeSceneRenderinMode","Default","rendering_mode_label","domProps","_s","toggle_rendering_mode","model","hdri","clear_scene","_e","info","is_loading","staticStyle","handle_file_upload","toTrianglesDrawMode","geometry","drawMode","TrianglesDrawMode","console","warn","TriangleFanDrawMode","TriangleStripDrawMode","index","getIndex","indices","position","getAttribute","undefined","error","i","count","push","setIndex","numberOfTriangles","newIndices","getX","length","newGeometry","clone","clearGroups","GLTFLoader","Loader","constructor","manager","super","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsAnisotropyExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","load","url","onLoad","onProgress","onError","scope","resourcePath","path","LoaderUtils","extractUrlBase","itemStart","_onError","e","itemError","itemEnd","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","parse","gltf","setDRACOLoader","setDDSLoader","Error","setKTX2Loader","setMeshoptDecoder","callback","indexOf","unregister","splice","json","extensions","plugins","textDecoder","TextDecoder","JSON","ArrayBuffer","magic","decode","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","content","asset","version","GLTFParser","crossOrigin","fileLoader","plugin","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","setExtensions","setPlugins","parseAsync","Promise","resolve","reject","GLTFRegistry","objects","get","key","add","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_IRIDESCENCE","KHR_MATERIALS_ANISOTROPY","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","KHR_MATERIALS_EMISSIVE_STRENGTH","EXT_TEXTURE_WEBP","EXT_TEXTURE_AVIF","EXT_MESHOPT_COMPRESSION","EXT_MESH_GPU_INSTANCING","cache","refs","uses","_markDefs","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","_loadLight","lightIndex","cacheKey","dependency","lightDefs","lights","lightDef","lightNode","color","Color","setRGB","LinearSRGBColorSpace","range","DirectionalLight","target","set","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","assignExtrasToUserData","intensity","createUniqueName","getDependency","createNodeAttachment","self","then","_getNodeRef","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","assignTexture","SRGBColorSpace","all","extendMaterialParams","materialIndex","materials","emissiveStrength","emissiveIntensity","MeshPhysicalMaterial","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","scale","clearcoatNormalScale","Vector2","iridescenceFactor","iridescence","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessRange","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","sheenColor","sheenRoughness","sheen","sheenColorFactor","colorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","Infinity","colorArray","attenuationColor","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularColor","specularColorTexture","anisotropyStrength","anisotropy","anisotropyRotation","anisotropyTexture","loadTexture","textureIndex","textureDef","textures","options","loadTextureImage","source","isSupported","images","textureLoader","uri","handler","getHandler","detectSupport","image","Image","src","onload","onerror","height","loadBufferView","bufferView","bufferViews","extensionDef","buffer","decoder","supported","res","byteOffset","byteLength","stride","byteStride","decodeGltfBufferAsync","mode","filter","ready","result","decodeGltfBuffer","createNodeMesh","mesh","meshDef","meshes","primitive","primitives","WEBGL_CONSTANTS","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","attributesDef","attributes","accessor","results","nodeObject","pop","isGroup","children","instancedMeshes","m","Matrix4","p","Vector3","q","Quaternion","s","instancedMesh","InstancedMesh","material","TRANSLATION","fromBufferAttribute","ROTATION","SCALE","setMatrixAt","compose","attributeName","setAttribute","Object3D","prototype","copy","call","assignFinalMaterial","clear","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","BIN","body","headerView","DataView","header","slice","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","preload","decodePrimitive","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","decodeDracoFile","attribute","extendTexture","texture","transform","texCoord","channel","offset","rotation","fromArray","repeat","needsUpdate","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","copySampleValue_","values","valueSize","interpolate_","i1","t0","t","t1","stride2","stride3","td","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_q","GLTFCubicSplineQuaternionInterpolant","normalize","toArray","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","UNSIGNED_BYTE","UNSIGNED_SHORT","Int8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","TEXCOORD_3","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","OPAQUE","MASK","BLEND","createDefaultMaterial","MeshStandardMaterial","emissive","metalness","roughness","transparent","depthTest","side","FrontSide","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","gltfDef","extras","Object","assign","addMorphTargets","targets","hasMorphPosition","hasMorphNormal","hasMorphColor","il","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","normal","morphPositions","morphNormals","morphColors","morphAttributes","morphTargetsRelative","updateMorphTargets","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","attributesKey","keys","sort","getNormalizedComponentScale","getImageURIMimeType","search","_identityMatrix","associations","Map","primitiveCache","nodeCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","isSafari","isFirefox","firefoxVersion","navigator","test","userAgent","match","createImageBitmap","TextureLoader","ImageBitmapLoader","setCrossOrigin","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","catch","skinDefs","skins","meshDefs","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","camera","updateMappings","original","mappings","child","entries","_invokeOne","func","unshift","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","map","def","bufferIndex","bufferDef","buffers","resolveURL","bufferViewDef","accessorIndex","sparse","itemSize","TypedArray","BufferAttribute","pendingBufferViews","elementBytes","BYTES_PER_ELEMENT","itemBytes","bufferAttribute","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","SCALAR","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sourceIndex","sourceDef","sampler","promise","loadImageSource","flipY","startsWith","samplers","magFilter","minFilter","wrapS","wrapT","URL","webkitURL","sourceURI","isObjectURL","blob","Blob","mimeType","createObjectURL","isImageBitmapLoader","imageBitmap","Texture","revokeObjectURL","mapName","mapDef","colorSpace","gltfReference","useDerivativeTangents","tangent","useVertexColors","useFlatShading","isPoints","uuid","pointsMaterial","PointsMaterial","Material","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","normalScale","y","materialType","materialExtensions","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","DoubleSide","alphaMode","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","aoMapIntensity","emissiveFactor","emissiveTexture","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","loadGeometries","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","BufferGeometry","meshIndex","geometries","SkinnedMesh","Mesh","normalizeSkinWeights","LineSegments","Line","LineLoop","Points","group","Group","cameraIndex","cameraDef","params","PerspectiveCamera","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","_loadNodeShallow","inverseBindMatrices","jointNodes","bones","boneInverses","jointNode","mat","Skeleton","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","node","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","updateMatrix","createdTracks","_createAnimationTracks","k","AnimationClip","traverse","o","isMesh","nodePending","childPending","childrenDef","skeletonPending","skeleton","bind","nodeName","meshPromise","forEach","Bone","matrix","applyMatrix4","quaternion","has","sceneIndex","sceneDef","nodeIds","reduceAssociations","reducedAssociations","value","targetName","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","interpolation","outputArray","_getArrayFromAccessor","j","jl","track","_createCubicSplineTrackInterpolant","scaled","createInterpolant","interpolantType","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","computeBounds","box","Box3","min","max","boxScale","multiplyScalar","maxDisplacement","vector","abs","expandByVector","boundingBox","sphere","Sphere","getCenter","center","radius","distanceTo","boundingSphere","assignAttributeAccessor","gltfAttributeName","ColorManagement","workingColorSpace","RGBELoader","DataTextureLoader","HalfFloatType","rgbe_read_error","rgbe_write_error","rgbe_format_error","rgbe_memory_error","rgbe_error","rgbe_error_code","msg","RGBE_VALID_PROGRAMTYPE","RGBE_VALID_FORMAT","RGBE_VALID_DIMENSIONS","NEWLINE","fgets","lineLimit","consume","chunkSize","pos","len","chunk","fromCharCode","subarray","RGBE_ReadHeader","magic_token_re","gamma_re","exposure_re","format_re","dimensions_re","valid","string","comments","programtype","format","gamma","exposure","width","line","charAt","parseFloat","parseInt","RGBE_ReadPixels_RLE","w","h","scanline_width","data_rgba","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","isEncodedRun","byteValue","l","off","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","pow","RGBEByteToRGBHalf","DataUtils","toHalfFloat","byteArray","rgbe_header_info","image_rgba_data","numElements","FloatType","floatArray","halfArray","setDataType","onLoadCallback","texData","generateMipmaps","_taskCache","WeakMap","DRACOLoader","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","uv","defaultAttributeTypes","setDecoderPath","setDecoderConfig","config","setWorkerLimit","attributeIDs","attributeTypes","vertexColorSpace","taskConfig","useUniqueIDs","decodeGeometry","taskKey","stringify","cachedTask","worker","taskID","taskCost","geometryPending","_getWorker","_worker","_callbacks","postMessage","id","message","_createGeometry","_releaseTask","geometryData","_assignVertexColorSpace","inputColorSpace","_color","convertSRGBToLinear","setXYZ","r","g","b","_loadLibrary","responseType","_initDecoder","useJS","WebAssembly","librariesPending","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","substring","lastIndexOf","join","Worker","_taskCosts","_taskLoad","onmessage","a","debug","log","dispose","terminate","draco","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","DecodeArrayToMesh","POINT_CLOUD","PointCloud","DecodeArrayToPointCloud","ok","error_msg","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","attributeResult","decodeAttribute","decodeIndex","destroy","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","HEAPF32","_free","numComponents","num_components","numPoints","num_points","numValues","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","DT_FLOAT32","DT_INT8","DT_INT16","Int32Array","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","onModuleLoaded","DracoDecoderModule","module","Decoder","attr","draco_loader","gltf_loader","rgbe_loader","mixins","BaseComponent","components","ThreeRenderer","Preloader","mouse_mode","prev_pointer_position","x","grid","tiling","environment","flashlight","computed","$store","state","is_mobile_device","toLocaleLowerCase","model_src","hdri_src","orbit_controls_autorotate","orbit_controls_autorotate_speed","Number","orbit_controls_pan","orbit_controls_zoom","orbit_controls_rotate","reset_camera_on_space","default_camera_distance","model_orientation","debounce","set_loading","init","document","addEventListener","$refs","three_renderer","controls","maxDistance","maxPolarAngle","enableDamping","dampingFactor","rotateSpeed","zoomSpeed","panSpeed","enableZoom","enableRotate","enablePan","autoRotate","autoRotateSpeed","beforeDestroy","removeEventListener","watch","visible","new_val","old_val","background","async","set_hdri","load_hdri_file","set_model","load_gltf_file","THREE","fileInput","click","event","files","dataTransfer","file","load_file","fit_camera_to_model","bounding_box","setFromObject","size","getSize","max_dim","z","setScalar","reset_camera","get_file_extension","dispose_model","patch_model","element","alphaHash","file_src","mapping","set_camera_position","set_camera_target","keyCode","modes_count"],"sourceRoot":""}